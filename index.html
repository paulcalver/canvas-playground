<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mouse-repel images</title>
<style>
  html, body { margin: 0; height: 100%; width: 100%; overflow: hidden; }
  canvas { display: block; }
</style>
<canvas id="c"></canvas>
<script type="module">
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');

  // ----- sizing -----
  function resize() {
	c.width = window.innerWidth;
	c.height = window.innerHeight;
	// on resize, keep anchors inside bounds
	sprites.forEach(s => {
	  s.anchor.x = Math.min(Math.max(s.anchor.x, 0), c.width - s.w);
	  s.anchor.y = Math.min(Math.max(s.anchor.y, 0), c.height - s.h);
	});
  }
  window.addEventListener('resize', resize);

  // ----- input -----
  const mouse = { x: -9999, y: -9999, inside: false };
  c.addEventListener('mousemove', e => {
	const rect = c.getBoundingClientRect();
	mouse.x = e.clientX - rect.left;
	mouse.y = e.clientY - rect.top;
	mouse.inside = true;
  });
  c.addEventListener('mouseleave', () => { mouse.inside = false; });

  // ----- config -----
  const imageFiles = [
	"PAUL_CALVER_00001_TN.jpg",
	"PAUL_CALVER_00002_TN.jpg",
	"PAUL_CALVER_00003_TN.jpg",
	"PAUL_CALVER_00004_TN.jpg",
	"PAUL_CALVER_00005_TN.jpg"
  ];
  const IMG_PATH = "./images/tn/"; // change if needed

  const influenceRadius = 250;      // px, mouse influence distance
  const repelStrength   = 120000;   // bigger = stronger push
  const springK         = 0.08;     // spring constant back to anchor
  const damping         = 0.86;     // velocity damping 0..1
  const maxSpeed        = 40;       // clamp to avoid tunnelling

  // ----- sprite state -----
  const sprites = [];

  function randRange(min, max) { return min + Math.random() * (max - min); }

  function placeRandomAnchor(w, h) {
	const pad = 20;
	return {
	  x: randRange(pad, Math.max(pad, c.width  - w - pad)),
	  y: randRange(pad, Math.max(pad, c.height - h - pad))
	};
  }

  // Load all images then start
  Promise.all(imageFiles.map(src => loadImage(IMG_PATH + src)))
	.then(imgs => {
	  resize();
	  imgs.forEach(img => {
		const anchor = placeRandomAnchor(img.width, img.height);
		sprites.push({
		  img,
		  w: img.width,
		  h: img.height,
		  // start at anchor
		  x: anchor.x,
		  y: anchor.y,
		  vx: 0, vy: 0,
		  anchor: { x: anchor.x, y: anchor.y }
		});
	  });
	  requestAnimationFrame(tick);
	})
	.catch(err => console.error("Image load error:", err));

  function loadImage(src) {
	return new Promise((resolve, reject) => {
	  const img = new Image();
	  img.onload = () => resolve(img);
	  img.onerror = reject;
	  img.src = src;
	});
  }

  function tick() {
	// physics
	sprites.forEach(s => {
	  // spring back to anchor
	  const axSpring = (s.anchor.x - s.x) * springK;
	  const aySpring = (s.anchor.y - s.y) * springK;

	  // mouse repulsion
	  let axRepel = 0, ayRepel = 0;
	  if (mouse.inside) {
		// use sprite centre for nicer feel
		const cx = s.x + s.w / 2;
		const cy = s.y + s.h / 2;
		const dx = cx - mouse.x;
		const dy = cy - mouse.y;
		const distSq = dx*dx + dy*dy;
		const r = influenceRadius;
		if (distSq < r*r && distSq > 0.0001) {
		  // inverse-square falloff with softening
		  const force = repelStrength / (distSq + 1000);
		  // push away from mouse
		  const dist = Math.sqrt(distSq);
		  axRepel = (dx / dist) * force;
		  ayRepel = (dy / dist) * force;
		}
	  }

	  // integrate
	  s.vx = (s.vx + axSpring + axRepel) * damping;
	  s.vy = (s.vy + aySpring + ayRepel) * damping;

	  // clamp speed
	  const spd = Math.hypot(s.vx, s.vy);
	  if (spd > maxSpeed) {
		s.vx *= maxSpeed / spd;
		s.vy *= maxSpeed / spd;
	  }

	  s.x += s.vx;
	  s.y += s.vy;

	  // keep within bounds a bit
	  if (s.x < 0) { s.x = 0; s.vx *= -0.4; }
	  if (s.y < 0) { s.y = 0; s.vy *= -0.4; }
	  if (s.x > c.width - s.w)  { s.x = c.width - s.w;   s.vx *= -0.4; }
	  if (s.y > c.height - s.h) { s.y = c.height - s.h;  s.vy *= -0.4; }
	});

	// draw
	ctx.clearRect(0, 0, c.width, c.height);
	sprites.forEach(s => ctx.drawImage(s.img, s.x, s.y, s.w, s.h));

	requestAnimationFrame(tick);
  }

  // kick off initial sizing
  resize();
</script>
</html>